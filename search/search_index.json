{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"The Parliament","text":"<p>A microservices-based social networking platform for UCC students</p>"},{"location":"#overview","title":"Overview","text":"<p>The Parliament is a location-aware social platform that enables students to build inner circles, create events, form groups, and discover who's nearby in real-time.</p>"},{"location":"#core-features","title":"Core Features","text":"<p>Inner Circles - Connect with close friends through invitation-based circles where you can share location and events exclusively.</p> <p>Events - Create and RSVP to events with flexible visibility (public, private, inner circle, or group-specific). Organize gatherings with attendee limits and automated invitations.</p> <p>Groups - Form and join communities around shared interests. Public groups for discovery, private groups for exclusivity.</p> <p>Location Sharing - Real-time map showing friends' locations with granular privacy controls. See who's nearby and gauge distances to meet up.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>The Parliament uses a microservices architecture with six core services:</p> <ul> <li>Auth Service - User registration, authentication, and profile management</li> <li>Circle Service - Inner circle invitations and friend connections</li> <li>Groups Service - Group creation, membership, and discovery</li> <li>Events Service - Event management and RSVP tracking</li> <li>Proximity Service - Real-time location sharing and map functionality</li> </ul> <p>Built with FastAPI, PostgreSQL, Docker, NGINX,  and Jinja frontend.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>System Overview - Architecture diagrams, end-to-end flows, and directory structure</li> <li>Service Documentation - API references and design docs for each microservice</li> <li>Development Guide - Setup instructions, testing, and deployment</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Architecture Overview</li> <li>End-to-End Flow</li> <li>API Reference - Auth</li> </ul>"},{"location":"Architecture/","title":"Architecture Diagram","text":"<p>This diagram represents the high-level architecture of the system. </p> <p>Each box is a service or component, and arrows indicate REST data flow.</p> <p></p>"},{"location":"Architecture/#components","title":"Components","text":"<ul> <li>Frontend: Server Side HTML Rendering with Jinja.</li> <li>API GATEWAY: The entry point for all client requests, routes to backend services.</li> <li>AUTH SERVICE: Handles authentication and user login.</li> <li>PROXIMITY SERVICE: Manages proximity-based features.</li> <li>EVENT MANAGEMENT SERVICE: Manages events and interacts with notification bus.</li> <li>GROUP MANAGEMENT SERVICE: Handles group-related features and interacts with event management.</li> <li>CIRCLE MANAGEMENT SERVICE: Handles circle-related features and interacts with event management.</li> </ul> <p>Arrows represent the main flows and dependencies between the gateway and each service.</p>"},{"location":"Architecture/#architectural-patterns","title":"Architectural Patterns","text":"<ul> <li>Strong Separation of Frontend and Backend:</li> <li>The backend services are completely decoupled from the frontend. Backend services do not generate or serve any HTML, CSS, or JavaScript; they only expose APIs for data and business logic.</li> <li> <p>The frontend (Server Side Renderer) is responsible for all user interface and presentation logic, consuming backend APIs via the API Gateway.</p> </li> <li> <p>Stateless, Loosely Coupled Services:</p> </li> <li> <p>Each backend service is independent and stateless, communicating only through well-defined API contracts.</p> </li> <li>Services do not share state or implementation details, enabling independent development, deployment, and scaling.</li> <li> <p>Each microservice is responsible for its own database schema. There are no foreign key constraints or direct database links between services; all relationships are managed at the application/API level. This ensures loose coupling, independent scaling, and clear service boundaries.</p> </li> <li> <p>Authentication and User Identity:</p> </li> <li>Upon registration, the Auth Service generates a unique integer user ID for each user.</li> <li>The frontend stores and reuses this user ID for all subsequent interactions with backend services, ensuring consistent user identification across the system.</li> </ul> <p>These patterns enable flexibility, scalability, and maintainability, and are well-suited for modern microservices-based architectures.</p>"},{"location":"Directory_structrure/","title":"Directory Structure","text":""},{"location":"Directory_structrure/#directory-birds-eye","title":"Directory Birds Eye","text":"<pre><code>.                                  # Project root\n\u251c\u2500\u2500 api_gateway/                   # Nginx reverse proxy (API Gateway, serves public port 80)\n\u2502   \u251c\u2500\u2500 Dockerfile                 # Build config for API Gateway\n\u2502   \u2514\u2500\u2500 conf.d/\n\u2502       \u2514\u2500\u2500 default.conf           # Nginx backend routing config for gateway\n\u251c\u2500\u2500 backend/                       # All backend microservices\n\u2502   \u2514\u2500\u2500 auth_service/              # Authentication service (FastAPI)\n\u2502       \u251c\u2500\u2500 Dockerfile             # Build config for auth service\n\u2502       \u251c\u2500\u2500 main.py                # FastAPI app for auth\n\u2502       \u251c\u2500\u2500 requirements.txt       # Python dependencies for auth\n\u2502       \u2514\u2500\u2500 tests/                 # Unit and integration tests for auth_service\n\u2502           \u2514\u2500\u2500 test_main.py       # Example test file for auth endpoints\n\u251c\u2500\u2500 docs/                          # Project documentation\n\u2502   \u251c\u2500\u2500 architecture.md            # System architecture diagrams and notes\n\u2502   \u2514\u2500\u2500 end_to_end_flow.md         # End-to-end request/response flow\n\u251c\u2500\u2500 frontend/                      # Static frontend (HTML/JS/CSS)\n\u2502   \u251c\u2500\u2500 Dockerfile                 # Build config for frontend nginx\n\u2502   \u251c\u2500\u2500 index.html                 # Main HTML page\n\u2502   \u251c\u2500\u2500 js/                        # Frontend JavaScript\n\u2502   \u2502   \u2514\u2500\u2500 auth.js                # Auth-related JS logic\n\u2502   \u2514\u2500\u2500 nginx.conf                 # Custom nginx config (serves on 8080)\n\u251c\u2500\u2500 docker-compose.yml             # Multi-service orchestration config\n\u251c\u2500\u2500 README.md                      # Quick start and general info\n</code></pre>"},{"location":"end_to_end_flow/","title":"End-to-End Flow","text":"<p>This document explains the request flow through the system using a Mermaid sequence diagram. Each lifeline is labeled with its container name for clarity.</p>"},{"location":"end_to_end_flow/#1-initial-page-load-static-content","title":"1. Initial Page Load (Static Content)","text":"<pre><code>sequenceDiagram\n    participant Browser as Browser (user)\n    participant Gateway as &lt;&lt;Container&gt;&gt;&lt;br/&gt;api_gateway\n    participant Frontend as &lt;&lt;Container&gt;&gt;&lt;br/&gt;frontend\n\n    Browser-&gt;&gt;Gateway: GET http://localhost/\n    Note over Gateway: Resolves frontend on Docker network\n    Gateway-&gt;&gt;Frontend: Proxy static file request (e.g., /index.html, /js/auth.js)\n    Frontend--&gt;&gt;Gateway: Serve static file\n    Gateway--&gt;&gt;Browser: Return static file</code></pre>"},{"location":"end_to_end_flow/#2-user-clicks-login-button-api-call","title":"2. User Clicks Login Button (API Call)","text":"<pre><code>sequenceDiagram\n    participant Browser as Browser (user)\n    participant Gateway as &lt;&lt;Container&gt;&gt;&lt;br/&gt;api_gateway\n    participant Auth as &lt;&lt;Container&gt;&gt;&lt;br/&gt;auth_service \n\n    Browser-&gt;&gt;Gateway: POST http://localhost/auth/login {JSON: Form Data}\n    loop nginx strips /auth\n        Gateway-&gt;&gt;Gateway: Rewrite URI: /auth/login \u2192 /login\n    end\n    Note over Gateway: Resolves auth_service on Docker network\n    Gateway-&gt;&gt;Auth: POST /login {JSON: Form Data}\n    Auth--&gt;&gt;Gateway: API response (e.g., success/failure)\n    Gateway--&gt;&gt;Browser: Return API response</code></pre>"},{"location":"end_to_end_flow/#flow-explanation","title":"Flow Explanation","text":"<ul> <li>Browser: The user's web browser.</li> <li>api_gateway (container): nginx reverse proxy, entrypoint for all requests.</li> <li>frontend (container): Serves static files (HTML, JS, CSS).</li> <li> <p>auth_service (container): Handles authentication API requests.</p> </li> <li> <p>Initial Load: The browser requests the main page. The gateway proxies this to the frontend container, which serves the static files.</p> </li> <li>User Interaction: When the user clicks the login button, the browser (via JavaScript) sends a POST request to <code>/auth/login</code>. The gateway proxies this to the auth_service container, which processes the login and returns a response.</li> </ul> <p>This separation clarifies the difference between static content delivery and dynamic API interaction.</p>"},{"location":"auth/auth_api/","title":"Auth Service","text":"<p>Base path: <code>/auth</code> Port: 8001 (internal)</p>"},{"location":"auth/auth_api/#endpoints","title":"Endpoints","text":"Method Endpoints Request Body/Query Params Response POST <code>/register</code> Body: <code>username, password, email, phonenumber</code> <code>user_id, message</code> POST <code>/login</code> Body: <code>username, password</code> <code>access_token, refresh_token, token_type</code> POST <code>/refresh</code> Body: <code>refresh_token</code> <code>access_token, refresh_token, token_type</code> POST <code>/logout</code> Head: <code>Authorization</code> Body: <code>refresh_token</code> <code>message</code> GET <code>/users/me</code> Head: <code>Authorization</code> <code>username, password, email, phonenumber</code> POST <code>/users/me</code> Head: <code>Authorization</code> Body: <code>username, email, phonenumber</code> <code>username, email, phonenumber</code> PUT <code>/users/me/password</code> Head: <code>Authorization</code> Body: <code>old_password, new_password</code> <code>message</code> GET <code>/users/{user_id}</code> Head: <code>Authorization</code> Path: <code>user_id</code> <code>username, user_id</code>"},{"location":"auth/auth_design/","title":"User Managment Design","text":"<p>At it's most basic, Registation simply services a <code>POST</code> HTTP message, extracts the json payload <code>{user info, password etc}</code> and persists to a database owned exclusively by the authentication microservice.</p> <p>The DB should, as its primary key, autogenerate an integer which would be a unique id for the user.</p> <p>However the question is - for a new user how do all the other microservices become aware of this new user? There are 2 options.</p> <ul> <li>Leverage jwt tokens and lazy-discover. JWT should be used anyway for security reasons. But we put the <code>user_id</code> into the token payload and encrypt it. Then all subsequent calls to other services - which receive the token and have to verify it anyway, can pluck the <code>user_id</code> from the jwt token. If its the first time they see that <code>user_id</code> value, this implies its the first time this user has called them. We trust the jwt, so that implies we trust the payload, so we know for sure the user exists. Just go update the logic for adding a new user - this is called lazy discover.</li> </ul> <pre><code>sequenceDiagram\n    actor User\n    participant API as api_gateway\n    participant Auth as auth\n    participant DB as datastore\n    participant Service as Every Other Microservice\n\n    Note over User, Service: Registration Flow Already Completed\n\n    User-&gt;&gt;API: GET /auth/login {username, password}\n    API-&gt;&gt;Auth: GET /login {username, password}\n    Auth-&gt;&gt;DB: db.query(username)\n    DB--&gt;&gt;Auth: User Data\n\n    Auth-&gt;&gt;Auth: isPasswordValid??\n    Note right of Auth: int user_id unique id&lt;br/&gt;auto generated by db\n\n    Auth-&gt;&gt;Auth: jwt_encode({user_id})\n    Auth--&gt;&gt;API: return {\"success\": true, \"token\": token}\n    API--&gt;&gt;User: return {\"success\": true, \"token\": token}\n\n    User-&gt;&gt;User: localstorage.setItem(token)\n    Note right of User: Browser js stores token.&lt;br/&gt;All other calls use it\n\n    Note over User, Service: Every other call can now uniquely identify the user.&lt;br/&gt;If Token is valid =&gt; User registered =&gt; Use user_id in payload to identify user\n\n    User-&gt;&gt;API: GET /service_name/service_call {token, ...}\n    API-&gt;&gt;Service: GET /service_call {token, ...}\n\n    rect rgb(240, 248, 255)\n    Note right of Service: if(payload = jwt.decode(token))&lt;br/&gt;user_id = payload.get(user_id)&lt;br/&gt;&lt;br/&gt;Not seen user_id before =&gt;&lt;br/&gt;first introduction =&gt; do&lt;br/&gt;whatever logic is required for a&lt;br/&gt;new user, then proceed with&lt;br/&gt;the service call logic.\n    Service-&gt;&gt;Service: verify_token(token)\n    end</code></pre>"},{"location":"circles/circles_api/","title":"Circle Service","text":"<p>The concept of a circle, is a grouping of users(people), Which is tightly controlled, e.g. a friendgroup. For simplicity we will assume a user can only be ONE circle. The pier GROUP SERVICE will allow users to join multiple groupings of individuals.</p> <p>Base path: <code>/circles</code> Port: 8002 (internal)</p>"},{"location":"circles/circles_api/#endpoints","title":"Endpoints","text":"Method Endpoints Request Body/Query Params Response POST <code>/invite</code> Head: <code>Authorization</code> Body: <code>inviter, invitee</code> <code>message</code> GET <code>/get_invites</code> Head: <code>Authorization</code> Array of: <code>inviter_usernames</code> GET <code>/get_invites_sent</code> Head: <code>Authorization</code> Array of: <code>inviter_usernames</code> POST <code>/accept</code> Head: <code>Authorization</code> Body: <code>inviter, invitee</code> <code>message</code> POST <code>/decline</code> Head: <code>Authorization</code> Body: <code>inviter, invitee</code> <code>message</code> GET <code>/mycircle</code> Head: <code>Authorization</code> Array of: <code>invitee_usernames</code> POST <code>/remove</code> Head: <code>Authorization</code> Body: <code>inviter, invitee</code> <code>message</code>"},{"location":"circles/circles_api/#state-machine","title":"State Machine","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; PENDING : send_invite\n\n    PENDING --&gt; ACCEPTED : accept\n    PENDING --&gt; DECLINED : decline\n\n    ACCEPTED --&gt; REMOVED : remove\n\n    DECLINED --&gt; [*]\n    REMOVED --&gt; [*]</code></pre>"},{"location":"circles/circles_design/","title":"Circles Service Design","text":"<p>Circles are the social core of the application: small, invitation-based groups representing close friendships. The defining data model decision is the invitation state machine. A circle membership passes through explicit states \u2014 invited, accepted, declined, removed \u2014 and the service enforces valid transitions. This prevents a user from appearing in circle queries before their invitation is accepted.</p> <p>The circle boundary is also the privacy boundary for location sharing. Onlyaccepted circle members can see each other's positions in the Proximity service. The Circles service is the authority on membership; the Proximity service delegates that question rather than reimplementing it.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; PENDING : send_invite\n\n    PENDING --&gt; ACCEPTED : accept\n    PENDING --&gt; DECLINED : decline\n\n    ACCEPTED --&gt; REMOVED : remove\n\n    DECLINED --&gt; [*]\n    REMOVED --&gt; [*]</code></pre>"},{"location":"events/events_api/","title":"Events Service","text":"<p>Base path: <code>/events</code> Port: 8005 (internal)</p>"},{"location":"events/events_api/#endpoints","title":"Endpoints","text":"Method Endpoints Request Body/Query Params Response POST <code>/create</code> Head: <code>Authorization</code> Body: <code>title</code> <code>description</code> <code>date</code> <code>time</code> <code>location</code> <code>event_id</code> <code>title</code> <code>description</code> <code>date</code> <code>time</code> <code>location</code> GET <code>/eventinfo</code> Head: <code>Authorization</code> Body: <code>event_id</code> <code>event_id</code> <code>title</code> <code>description</code> <code>date</code> <code>time</code> <code>location</code> GET <code>/search</code> Head: <code>Authorization</code> Body: <code>location?</code> <code>date_from</code> <code>date_to</code> array of <code>event_id</code> <code>title</code> <code>date</code> <code>time</code> <code>location</code> POST <code>/rsvp</code> Head: <code>Authorization</code> Body: <code>event_id</code> <code>status</code>(accept/maybe/decline) <code>message</code> <code>status</code> POST <code>/invitecircle</code> Head: <code>Authorization</code> Body: <code>event_id</code> <code>message</code> POST <code>/invitegroup</code> Head: <code>Authorization</code> Body: <code>event_id</code> <code>message</code> POST <code>/cancel</code> Head: <code>Authorization</code> Body: <code>event_id</code> <code>message</code> <code>status: canceled</code> PUT <code>/edit</code> Head: <code>Authorization</code> Body: <code>event_id</code> <code>title</code> <code>description</code> <code>date</code> <code>time</code> <code>location</code> <code>event_id</code> <code>title</code> <code>description</code> <code>date</code> <code>time</code> <code>location</code> GET <code>/myevents</code> Head: <code>Authorization</code> array of <code>event_id</code> <code>title</code> <code>description</code> <code>date</code> <code>time</code> <code>location</code>"},{"location":"events/events_design/","title":"Event Service","text":"<p>This service is responsible for Event Creation, invitations and RSVP managment. Document will be progressed parallel to progress.</p>"},{"location":"groups/groups_api/","title":"Group Service","text":"<p>Base path: <code>/groups</code> Port: 8003 (internal)</p>"},{"location":"groups/groups_api/#endpoints","title":"Endpoints","text":"Method Endpoints Request Body/Query Params Response POST <code>/create</code> Head: <code>Authorization</code> Body: <code>group_name</code> <code>description</code> <code>visibility (Public/Private)</code> <code>group_id</code> <code>group_name</code> GET <code>/list</code> Head: <code>Authorization</code> array of: <code>group_id</code>, <code>group_name</code>, <code>group_description</code> POST <code>/join</code> Head: <code>Authorization</code> Body: <code>group_id</code> <code>message</code> POST <code>/leave</code> Head: <code>Authorization</code> Body: <code>group_id</code> <code>message</code> GET <code>/mygroups</code> Head: <code>Authorization</code> array of: <code>group_id</code>, <code>group_name</code>, <code>group_description</code> GET <code>/listmembers</code> Head: <code>Authorization</code> Body: <code>group_id</code> array of <code>user_id</code>, <code>username</code>, DELETE <code>/removemember</code> Head: <code>Authorization</code> Body: <code>user_id</code> <code>message</code>"},{"location":"groups/groups_design/","title":"Group Service","text":"<p>Groups serve a different social function from Circles. Where a Circle is intimate and invitation-only, a Group is a community of shared interest that can be public or private. The distinction is set by the creator at the time of group creation. </p> <p>A public group is discoverable by any user via <code>/list</code> and open to join without any approval \u2014 any authenticated user can add themselves. </p> <p>A private group is invisible to non-members entirely; it does not appear in discovery at all. Rather than a request-and-approve flow, membership in a private group is entirely owner-controlled: only the creator can add users via <code>/join</code> on their behalf. This keeps the permission model simple \u2014 there is no pending state, no invite negotiation, the owner either adds someone or they are not in the group.</p> <p>The same owner authority extends to removal. The <code>/removemember</code> endpoint is restricted to the group owner \u2014 members cannot remove each other, only the creator can manage the roster. This binary owner/member model is intentionally lightweight for the scope of the project; a production system might introduce moderator roles, but for GoClub the distinction was sufficient.</p> <p>The public/private flag also propagates into the Events service: an event scoped to a group is only visible to its members, so the Events service must resolve group membership at query time. The Groups service remains the single source of truth for membership, and the Events service defers to it rather than duplicating that logic.</p>"},{"location":"proximity/proximity_api/","title":"Proximity Service","text":"<p>Base path: <code>/proximity</code> Port: 8004 (internal)</p>"},{"location":"proximity/proximity_api/#endpoints","title":"Endpoints","text":"Method Endpoints Request Body/Query Params Response POST <code>/updatelocation</code> Head: <code>Authorization</code> Body: <code>longitude</code>, <code>latitude</code> <code>message</code> <code>updated_at</code> POST <code>/setvisibility</code> Head: <code>Authorization</code> Body: <code>visibility</code> (private/inner_circle/groups/public) <code>visibility</code> <code>updated_at</code> GET <code>/friendslocation</code> Head: <code>Authorization</code> Body: <code>radius</code> array of <code>user_id</code> <code>username</code> <code>latitude</code> <code>longitude</code> <code>distance</code>"},{"location":"proximity/proximity_design/","title":"Proximity Service","text":"<p>The Proximity Service offers the ability to a user to update its geolocation. Holding all the locations of all users, the proximity service allows a specific user to retrieve the location of friends in their circle.</p>"},{"location":"proximity/proximity_design/#why-valkey-over-standard-database","title":"Why Valkey Over Standard Database?","text":"<p>Valkey is chosen for the Proximity Service due to its specialized geospatial capabilities:</p> <ol> <li> <p>Built-in Geospatial Commands: Valkey provides native <code>GEOADD</code>, <code>GEORADIUS</code>, and <code>GEODIST</code> commands optimized for location-based queries. A standard relational database would require complex mathematical formulas (like calculating distances on a sphere) or special plugins. Basically, you'd have to do a lot of extra work that Valkey already handles for you.</p> </li> <li> <p>Sub-millisecond Performance: In-memory storage enables extremely fast reads/writes for location updates. Users update locations frequently (every few seconds while moving), the more users updating, the more of a bottleneck writing to the db on disk would becom..</p> </li> <li> <p>High Write Throughput: Location updates are write-heavy. Valkey handles millions of writes/second, whereas traditional databases would require more elaborate solutions like connection pooling to handle.</p> </li> <li> <p>TTL Support: Locations can auto-expire if users go offline (using <code>EXPIRE</code>), keeping data fresh without manual cleanup jobs.</p> </li> </ol>"},{"location":"proximity/proximity_design/#sequence-diagrams","title":"Sequence Diagrams","text":""},{"location":"proximity/proximity_design/#update-location","title":"Update Location","text":"<pre><code>sequenceDiagram\n    participant Proximity\n    participant Auth\n    participant Valkey\n\n    Note right of Proximity: POST /updatelocation received&lt;br/&gt;{user_id, lat, lon}\n\n    alt Username NOT in local cache\n        Proximity-&gt;&gt;Auth: POST /getusername&lt;br/&gt;{user_id}\n        Auth--&gt;&gt;Proximity: {username}\n        Proximity-&gt;&gt;Proximity: Store in local cache\n    end\n\n    Proximity-&gt;&gt;Valkey: GEOADD locations:live &lt;lon&gt; &lt;lat&gt; &lt;user_id&gt;\n    Valkey--&gt;&gt;Proximity: OK\n\n    Note right of Proximity: 200 OK returned</code></pre> <p>Key Design: - Geospatial key: <code>locations:live</code> (global sorted set storing all user locations) - Username cache key: <code>user:phonebook</code> (hash mapping user_id \u2192 username) - Valkey command: <code>GEOADD user:locations &lt;longitude&gt; &lt;latitude&gt; &lt;user_id&gt;</code>   - Note: GEO commands expect longitude first, then latitude   - user_id serves as the member identifier in the sorted set</p>"},{"location":"proximity/proximity_design/#get-friends-inside-radius","title":"Get Friends Inside Radius","text":"<pre><code>sequenceDiagram\n    participant Proximity\n    participant Circle\n    participant Valkey\n\n    Note right of Proximity: GET /friendslocation received&lt;br/&gt;{user_id, lat, lon, radius}\n\n    Proximity-&gt;&gt;Circle: GET /mycircle&lt;br/&gt;{user_id}\n    Circle--&gt;&gt;Proximity: [{user_id, username}]\n\n    Proximity-&gt;&gt;Valkey: GEORADIUS live_locations &lt;lon&gt; &lt;lat&gt; &lt;radius&gt; m\n    Valkey--&gt;&gt;Proximity: [user_id_1, user_id_2, ...]\n\n    Proximity-&gt;&gt;Proximity: Filter: circle \u2229 nearby\n\n    Proximity-&gt;&gt;Proximity: Return friends within radus\n\n    Note right of Proximity: 200 OK&lt;br/&gt;[{user_id, username, lat, lon, distance}]</code></pre> <p>```</p>"},{"location":"proximity/proximity_design/#notes","title":"Notes","text":"<ul> <li>Location updates should include timestamp expiry (e.g., <code>EXPIRE user:locations:&lt;user_id&gt; 3600</code>) to auto-remove stale locations</li> <li>Local username cache in Proximity service reduces Auth service calls</li> </ul>"}]}